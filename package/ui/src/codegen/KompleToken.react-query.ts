/**
 * This file was automatically generated by @cosmwasm/ts-codegen@0.30.0.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */

import {
  UseQueryOptions,
  useQuery,
  useMutation,
  UseMutationOptions,
} from "@tanstack/react-query";
import { ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import { StdFee, Coin } from "@cosmjs/amino";
import {
  Timestamp,
  Uint64,
  Collections,
  Metadata,
  InstantiateMsg,
  CollectionConfig,
  MetadataInfo,
  InstantiateMsg1,
  TokenInfo,
  ExecuteMsg,
  Binary,
  Locks,
  WhitelistConfig,
  QueryMsg,
  MigrateMsg,
  Addr,
  ResponseWrapperForConfig,
  Config,
  ResponseWrapperForLocks,
  ResponseWrapperForUint32,
  ResponseWrapperForArrayOfString,
  ResponseWrapperForSubModules,
  SubModules,
} from "./KompleToken.types";
import {
  KompleTokenQueryClient,
  KompleTokenClient,
} from "./KompleToken.client";
export const kompleTokenQueryKeys = {
  contract: [
    {
      contract: "kompleToken",
    },
  ] as const,
  address: (contractAddress: string | undefined) =>
    [
      { ...kompleTokenQueryKeys.contract[0], address: contractAddress },
    ] as const,
  locks: (
    contractAddress: string | undefined,
    args?: Record<string, unknown>
  ) =>
    [
      {
        ...kompleTokenQueryKeys.address(contractAddress)[0],
        method: "locks",
        args,
      },
    ] as const,
  tokenLocks: (
    contractAddress: string | undefined,
    args?: Record<string, unknown>
  ) =>
    [
      {
        ...kompleTokenQueryKeys.address(contractAddress)[0],
        method: "token_locks",
        args,
      },
    ] as const,
  mintedTokensPerAddress: (
    contractAddress: string | undefined,
    args?: Record<string, unknown>
  ) =>
    [
      {
        ...kompleTokenQueryKeys.address(contractAddress)[0],
        method: "minted_tokens_per_address",
        args,
      },
    ] as const,
  subModules: (
    contractAddress: string | undefined,
    args?: Record<string, unknown>
  ) =>
    [
      {
        ...kompleTokenQueryKeys.address(contractAddress)[0],
        method: "sub_modules",
        args,
      },
    ] as const,
  config: (
    contractAddress: string | undefined,
    args?: Record<string, unknown>
  ) =>
    [
      {
        ...kompleTokenQueryKeys.address(contractAddress)[0],
        method: "config",
        args,
      },
    ] as const,
  moduleOperators: (
    contractAddress: string | undefined,
    args?: Record<string, unknown>
  ) =>
    [
      {
        ...kompleTokenQueryKeys.address(contractAddress)[0],
        method: "module_operators",
        args,
      },
    ] as const,
};
export const kompleTokenQueries = {
  locks: <TData = ResponseWrapperForLocks>({
    client,
    options,
  }: KompleTokenLocksQuery<TData>): UseQueryOptions<
    ResponseWrapperForLocks,
    Error,
    TData
  > => ({
    queryKey: kompleTokenQueryKeys.locks(client?.contractAddress),
    queryFn: () =>
      client ? client.locks() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled:
      !!client && (options?.enabled != undefined ? options.enabled : true),
  }),
  tokenLocks: <TData = ResponseWrapperForLocks>({
    client,
    args,
    options,
  }: KompleTokenTokenLocksQuery<TData>): UseQueryOptions<
    ResponseWrapperForLocks,
    Error,
    TData
  > => ({
    queryKey: kompleTokenQueryKeys.tokenLocks(client?.contractAddress, args),
    queryFn: () =>
      client
        ? client.tokenLocks({
            tokenId: args.tokenId,
          })
        : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled:
      !!client && (options?.enabled != undefined ? options.enabled : true),
  }),
  mintedTokensPerAddress: <TData = ResponseWrapperForUint32>({
    client,
    args,
    options,
  }: KompleTokenMintedTokensPerAddressQuery<TData>): UseQueryOptions<
    ResponseWrapperForUint32,
    Error,
    TData
  > => ({
    queryKey: kompleTokenQueryKeys.mintedTokensPerAddress(
      client?.contractAddress,
      args
    ),
    queryFn: () =>
      client
        ? client.mintedTokensPerAddress({
            address: args.address,
          })
        : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled:
      !!client && (options?.enabled != undefined ? options.enabled : true),
  }),
  subModules: <TData = ResponseWrapperForSubModules>({
    client,
    options,
  }: KompleTokenSubModulesQuery<TData>): UseQueryOptions<
    ResponseWrapperForSubModules,
    Error,
    TData
  > => ({
    queryKey: kompleTokenQueryKeys.subModules(client?.contractAddress),
    queryFn: () =>
      client
        ? client.subModules()
        : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled:
      !!client && (options?.enabled != undefined ? options.enabled : true),
  }),
  config: <TData = ResponseWrapperForConfig>({
    client,
    options,
  }: KompleTokenConfigQuery<TData>): UseQueryOptions<
    ResponseWrapperForConfig,
    Error,
    TData
  > => ({
    queryKey: kompleTokenQueryKeys.config(client?.contractAddress),
    queryFn: () =>
      client ? client.config() : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled:
      !!client && (options?.enabled != undefined ? options.enabled : true),
  }),
  moduleOperators: <TData = ResponseWrapperForArrayOfString>({
    client,
    options,
  }: KompleTokenModuleOperatorsQuery<TData>): UseQueryOptions<
    ResponseWrapperForArrayOfString,
    Error,
    TData
  > => ({
    queryKey: kompleTokenQueryKeys.moduleOperators(client?.contractAddress),
    queryFn: () =>
      client
        ? client.moduleOperators()
        : Promise.reject(new Error("Invalid client")),
    ...options,
    enabled:
      !!client && (options?.enabled != undefined ? options.enabled : true),
  }),
};
export interface KompleTokenReactQuery<TResponse, TData = TResponse> {
  client: KompleTokenQueryClient | undefined;
  options?: Omit<
    UseQueryOptions<TResponse, Error, TData>,
    "'queryKey' | 'queryFn' | 'initialData'"
  > & {
    initialData?: undefined;
  };
}
export type KompleTokenModuleOperatorsQuery<TData> = KompleTokenReactQuery<
  ResponseWrapperForArrayOfString,
  TData
>;
export function useKompleTokenModuleOperatorsQuery<
  TData = ResponseWrapperForArrayOfString
>({ client, options }: KompleTokenModuleOperatorsQuery<TData>) {
  return useQuery<ResponseWrapperForArrayOfString, Error, TData>(
    kompleTokenQueryKeys.moduleOperators(client?.contractAddress),
    () =>
      client
        ? client.moduleOperators()
        : Promise.reject(new Error("Invalid client")),
    {
      ...options,
      enabled:
        !!client && (options?.enabled != undefined ? options.enabled : true),
    }
  );
}
export type KompleTokenConfigQuery<TData> = KompleTokenReactQuery<
  ResponseWrapperForConfig,
  TData
>;
export function useKompleTokenConfigQuery<TData = ResponseWrapperForConfig>({
  client,
  options,
}: KompleTokenConfigQuery<TData>) {
  return useQuery<ResponseWrapperForConfig, Error, TData>(
    kompleTokenQueryKeys.config(client?.contractAddress),
    () =>
      client ? client.config() : Promise.reject(new Error("Invalid client")),
    {
      ...options,
      enabled:
        !!client && (options?.enabled != undefined ? options.enabled : true),
    }
  );
}
export type KompleTokenSubModulesQuery<TData> = KompleTokenReactQuery<
  ResponseWrapperForSubModules,
  TData
>;
export function useKompleTokenSubModulesQuery<
  TData = ResponseWrapperForSubModules
>({ client, options }: KompleTokenSubModulesQuery<TData>) {
  return useQuery<ResponseWrapperForSubModules, Error, TData>(
    kompleTokenQueryKeys.subModules(client?.contractAddress),
    () =>
      client
        ? client.subModules()
        : Promise.reject(new Error("Invalid client")),
    {
      ...options,
      enabled:
        !!client && (options?.enabled != undefined ? options.enabled : true),
    }
  );
}
export interface KompleTokenMintedTokensPerAddressQuery<TData>
  extends KompleTokenReactQuery<ResponseWrapperForUint32, TData> {
  args: {
    address: string;
  };
}
export function useKompleTokenMintedTokensPerAddressQuery<
  TData = ResponseWrapperForUint32
>({ client, args, options }: KompleTokenMintedTokensPerAddressQuery<TData>) {
  return useQuery<ResponseWrapperForUint32, Error, TData>(
    kompleTokenQueryKeys.mintedTokensPerAddress(client?.contractAddress, args),
    () =>
      client
        ? client.mintedTokensPerAddress({
            address: args.address,
          })
        : Promise.reject(new Error("Invalid client")),
    {
      ...options,
      enabled:
        !!client && (options?.enabled != undefined ? options.enabled : true),
    }
  );
}
export interface KompleTokenTokenLocksQuery<TData>
  extends KompleTokenReactQuery<ResponseWrapperForLocks, TData> {
  args: {
    tokenId: string;
  };
}
export function useKompleTokenTokenLocksQuery<TData = ResponseWrapperForLocks>({
  client,
  args,
  options,
}: KompleTokenTokenLocksQuery<TData>) {
  return useQuery<ResponseWrapperForLocks, Error, TData>(
    kompleTokenQueryKeys.tokenLocks(client?.contractAddress, args),
    () =>
      client
        ? client.tokenLocks({
            tokenId: args.tokenId,
          })
        : Promise.reject(new Error("Invalid client")),
    {
      ...options,
      enabled:
        !!client && (options?.enabled != undefined ? options.enabled : true),
    }
  );
}
export type KompleTokenLocksQuery<TData> = KompleTokenReactQuery<
  ResponseWrapperForLocks,
  TData
>;
export function useKompleTokenLocksQuery<TData = ResponseWrapperForLocks>({
  client,
  options,
}: KompleTokenLocksQuery<TData>) {
  return useQuery<ResponseWrapperForLocks, Error, TData>(
    kompleTokenQueryKeys.locks(client?.contractAddress),
    () =>
      client ? client.locks() : Promise.reject(new Error("Invalid client")),
    {
      ...options,
      enabled:
        !!client && (options?.enabled != undefined ? options.enabled : true),
    }
  );
}
export interface KompleTokenInitWhitelistContractMutation {
  client: KompleTokenClient;
  msg: {
    codeId: number;
    instantiateMsg: InstantiateMsg;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useKompleTokenInitWhitelistContractMutation(
  options?: Omit<
    UseMutationOptions<
      ExecuteResult,
      Error,
      KompleTokenInitWhitelistContractMutation
    >,
    "mutationFn"
  >
) {
  return useMutation<
    ExecuteResult,
    Error,
    KompleTokenInitWhitelistContractMutation
  >(
    ({ client, msg, args: { fee, memo, funds } = {} }) =>
      client.initWhitelistContract(msg, fee, memo, funds),
    options
  );
}
export interface KompleTokenUpdateCollectionConfigMutation {
  client: KompleTokenClient;
  msg: {
    collectionConfig: CollectionConfig;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useKompleTokenUpdateCollectionConfigMutation(
  options?: Omit<
    UseMutationOptions<
      ExecuteResult,
      Error,
      KompleTokenUpdateCollectionConfigMutation
    >,
    "mutationFn"
  >
) {
  return useMutation<
    ExecuteResult,
    Error,
    KompleTokenUpdateCollectionConfigMutation
  >(
    ({ client, msg, args: { fee, memo, funds } = {} }) =>
      client.updateCollectionConfig(msg, fee, memo, funds),
    options
  );
}
export interface KompleTokenUpdateTokenLocksMutation {
  client: KompleTokenClient;
  msg: {
    locks: Locks;
    tokenId: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useKompleTokenUpdateTokenLocksMutation(
  options?: Omit<
    UseMutationOptions<
      ExecuteResult,
      Error,
      KompleTokenUpdateTokenLocksMutation
    >,
    "mutationFn"
  >
) {
  return useMutation<ExecuteResult, Error, KompleTokenUpdateTokenLocksMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) =>
      client.updateTokenLocks(msg, fee, memo, funds),
    options
  );
}
export interface KompleTokenUpdateLocksMutation {
  client: KompleTokenClient;
  msg: {
    locks: Locks;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useKompleTokenUpdateLocksMutation(
  options?: Omit<
    UseMutationOptions<ExecuteResult, Error, KompleTokenUpdateLocksMutation>,
    "mutationFn"
  >
) {
  return useMutation<ExecuteResult, Error, KompleTokenUpdateLocksMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) =>
      client.updateLocks(msg, fee, memo, funds),
    options
  );
}
export interface KompleTokenAdminTransferNftMutation {
  client: KompleTokenClient;
  msg: {
    recipient: string;
    tokenId: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useKompleTokenAdminTransferNftMutation(
  options?: Omit<
    UseMutationOptions<
      ExecuteResult,
      Error,
      KompleTokenAdminTransferNftMutation
    >,
    "mutationFn"
  >
) {
  return useMutation<ExecuteResult, Error, KompleTokenAdminTransferNftMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) =>
      client.adminTransferNft(msg, fee, memo, funds),
    options
  );
}
export interface KompleTokenUpdateModuleOperatorsMutation {
  client: KompleTokenClient;
  msg: {
    addrs: string[];
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useKompleTokenUpdateModuleOperatorsMutation(
  options?: Omit<
    UseMutationOptions<
      ExecuteResult,
      Error,
      KompleTokenUpdateModuleOperatorsMutation
    >,
    "mutationFn"
  >
) {
  return useMutation<
    ExecuteResult,
    Error,
    KompleTokenUpdateModuleOperatorsMutation
  >(
    ({ client, msg, args: { fee, memo, funds } = {} }) =>
      client.updateModuleOperators(msg, fee, memo, funds),
    options
  );
}
export interface KompleTokenBurnMutation {
  client: KompleTokenClient;
  msg: {
    tokenId: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useKompleTokenBurnMutation(
  options?: Omit<
    UseMutationOptions<ExecuteResult, Error, KompleTokenBurnMutation>,
    "mutationFn"
  >
) {
  return useMutation<ExecuteResult, Error, KompleTokenBurnMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) =>
      client.burn(msg, fee, memo, funds),
    options
  );
}
export interface KompleTokenMintMutation {
  client: KompleTokenClient;
  msg: {
    metadataId?: number;
    owner: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useKompleTokenMintMutation(
  options?: Omit<
    UseMutationOptions<ExecuteResult, Error, KompleTokenMintMutation>,
    "mutationFn"
  >
) {
  return useMutation<ExecuteResult, Error, KompleTokenMintMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) =>
      client.mint(msg, fee, memo, funds),
    options
  );
}
export interface KompleTokenSendNftMutation {
  client: KompleTokenClient;
  msg: {
    contract: string;
    msg: Binary;
    tokenId: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useKompleTokenSendNftMutation(
  options?: Omit<
    UseMutationOptions<ExecuteResult, Error, KompleTokenSendNftMutation>,
    "mutationFn"
  >
) {
  return useMutation<ExecuteResult, Error, KompleTokenSendNftMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) =>
      client.sendNft(msg, fee, memo, funds),
    options
  );
}
export interface KompleTokenTransferNftMutation {
  client: KompleTokenClient;
  msg: {
    recipient: string;
    tokenId: string;
  };
  args?: {
    fee?: number | StdFee | "auto";
    memo?: string;
    funds?: Coin[];
  };
}
export function useKompleTokenTransferNftMutation(
  options?: Omit<
    UseMutationOptions<ExecuteResult, Error, KompleTokenTransferNftMutation>,
    "mutationFn"
  >
) {
  return useMutation<ExecuteResult, Error, KompleTokenTransferNftMutation>(
    ({ client, msg, args: { fee, memo, funds } = {} }) =>
      client.transferNft(msg, fee, memo, funds),
    options
  );
}
